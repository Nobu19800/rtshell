# rtshell Bash completion
#
# Copyright (C) 2009-2010
#     Keisuke Suzuki and Geoffrey Biggs
#     RT-Synthesis Research Group
#     Intelligent Systems Research Institute,
#     National Institute of Advanced Industrial Science and Technology (AIST),
#     Japan
#     All rights reserved.
# Licensed under the Eclipse Public License -v 1.0 (EPL)
# http://www.opensource.org/licenses/eclipse-1.0.txt


# Overview
#
# Adds tab-completion functionality to rtshell. Can complete command options,
# directories, objects, ports and configuration parameter names.
#
# rtshellにbashの補完機能を追加するbash-completionスクリプト。
# コマンドオプションやディレクトリ、オブジェクト、ポート、パラメータ名を補完。
#
# Usage
#
#  $ source ${prefix}/share/rtshell/bash_completion
#
# Example: Directory completion / ディレクトリ名補完
#
#  $ rtcwd [TAB]
#  $ rtcwd localhost/
#  $ rtcwd localhost/[TAB]
#  $ rtcwd localhost/foo.host_cxt/
#  $ rtcwd localhost/foo.host_cxt/[TAB][TAB]
#  foo.rtc  bar.rtc  manager.mgr
#  $ rtcwd localhost/foo.host_cxt/[ENTER]
#
# Example: Configuration parameter completion / パラメータ名補完 (rtconf)
#
#  $ rtconf foo.rtc set [TAB]
#  param1  param2  param3
#
# Example: ポート名補完 (only rtcon rtdis)
#
#  $ rtcon foo.rtc:[TAB]
#  fooIn  barIn  fooOut  barOut
#


# Command option completion
# Usage : _rtopts ${COMP_WORDS[COMP_CWORD]}
#         _rtopts ${cur}
# Receives the currently-being-entered word.
_rtopts()
{
    local opts complist

    case ${COMP_WORDS[0]} in
        *rtact)     opts="--version -h --help -d --debug -e --exec_context="
                    ;;
        *rtcat)     opts="--version -h --help -l --ll -d --debug"
                    ;;
        *rtcwd)     opts=""
                    ;;
        *rtcon)     opts="--version -h --help -d --debug -i --id= -n --name= -p --property="
                    ;;
        *rtconf)    opts="--version -h --help -l -d --debug -s --set= -a --all"
                    ;;
        *rtdeact)   opts="--version -h --help -d --debug -e --exec_context="
                    ;;
        *rtdis)     opts="--version -h --help -d --debug"
                    ;;
        *rtfind)    opts="--version -h --help -d --debug --maxdepth= --iname= --name= --type="
                    ;;
        *rtls)      opts="--version -h --help -l -d --debug -r --recurse"
                    ;;
        *rtmgr)     opts="--version -h --help -d --debug"
                    ;;
        *rtreset)   opts="--version -h --help -d --debug -e --exec_context="
                    ;;
        *rtstart)   opts="--version -h --help --dry-run -v --verbose"
                    ;;
        *rtstop)    opts="--version -h --help --dry-run -v --verbose"
                    ;;
        *rtteardown)opts="--version -h --help --dry-run -v --verbose"
                    ;;
        *rtcryo)    opts="--version -h --help -a --abstract= -n --system-name= -o --output= -v --system-version= -e --vendor= --verbose"
                    ;;
        *rtresurrect)    opts="--version -h --help --dry-run -v --verbose"
                    ;;
        *rtprint)   opts="--version -h --help -d --debug"
                    ;;
        *rtinject)  opts="--version -h --help -d --debug"
                    ;;
        *)          ;;
    esac

    complist=$(compgen -W "${opts} ${nospaceopts}" -- $1)

    # If there is an = then don't add a space
    if [[ ${complist} == *= ]] ; then
        compopt -o nospace
    fi

    COMPREPLY=(${complist})
    return 0

}

# Complete object names
# Usage : _rtobj ${COMP_WORDS[COMP_CWORD]}
#         _rtobj ${cur}
#         _rtobj ${cur} port (when completing port names)
# Receives the currently-being-entered word.
_rtobj()
{
    local objs obj target_dir target_abs target_objs

    target_objs=""

    target_dir=`echo $1 | sed -e 's/\/[^\/]*$/\//g'`

    if [[ ${target_dir} != */ ]] ; then
        target_dir=""
    fi

    # Use col to remove colour codes
    objs=`rtls ${target_dir} 2> /dev/null | col | sed 's/00m//g' | sed 's/*//g'`

    target_objs=""
    for obj in ${objs} ; do
        target_objs="${target_objs} ${target_dir}${obj}"
    done

    target_objs=($(compgen -W "${target_objs}" -- $1))

    if [[ ${#target_objs[@]} == 1 ]] ; then
        # If the completion target is a directory or port, no space
        if [[ ${target_objs[0]} == */ ]] || [[ ${target_objs[0]} == *:  ]] ; then
                    compopt -o nospace
        elif [[  $2 == port ]] ; then
            target_objs[0]="${target_objs[0]}:"
            compopt -o nospace
        fi
    fi

    COMPREPLY=(${target_objs[@]})
}

_rtls()
{
    local cur prev
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    if [[ ${cur} == -* ]] ; then
        _rtopts ${cur}
        return 0
    fi

    _rtobj ${cur}
    return 0
}

_rtcon()
{
    local cur prev preprev colonopt
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    if [[ ${cur} == -* ]] ; then
            _rtopts ${cur}
            return 0
    fi

    # : is treated the same as a space for separating variables
    # Port completion 1
    if [[ ${cur} == : ]] ; then
        colonopt=$(rtcat ${prev} 2> /dev/null | grep Port: | col | sed 's/00m//g' | awk '{ print $2 }')
        COMPREPLY=(${colonopt})
        return 0
    fi

    # Port completion 2
    if [[ ${prev} == : ]] ; then
        preprev="${COMP_WORDS[COMP_CWORD-2]}"
        colonopt=`rtcat ${preprev} 2> /dev/null | grep Port: | col | sed 's/00m//g' | awk '{ print $2 }'`
        COMPREPLY=($(compgen -W "${colonopt}" -- ${cur}))
        return 0
    fi

    _rtobj "${cur}" port
    return 0
}

_get_set_opt_val()
{
    SET_OPT_VAL="$(grep ' \-s \| \-\-set=' <<< ${COMP_WORDS[@]} | \
        sed 's/.* \(-s \|--set=\)\([a-zA-Z0-9_]\+\).*/\2/')"
    return 0
}

_check_hidden()
{
    if $(grep -q ' \-a \| \-\-all ' <<< ${COMP_WORDS[@]})
    then
        ALL_SETS="-a"
    else
        ALL_SETS=""
    fi
    return 0
}

_rtconf_set_name()
{
    # $1 = path
    # $2 = current word
    _check_hidden
    local cur=${2#=}
    local setnames=$(rtconf ${1} ${ALL_SETS} 2> /dev/null | sed 's/^+//' | sed 's/*$//')
    COMPREPLY=($(compgen -W "${setnames}" -- ${cur}))
    return 0
}

_rtconf_param_name()
{
    # $1 = path
    # $2 = current word
    local params
    _get_set_opt_val
    _check_hidden
    if [[ "${SET_OPT_VAL}" == "" ]]; then
        # Param in active set
        params=$(rtconf ${1} ${ALL_SETS} -l 2> /dev/null | \
            sed -n '/^-/{:1;p;n;/^-/q;b1};p' | grep '^ ' | awk '{print $1}')
        COMPREPLY=($(compgen -W "${params}" -- ${2}))
    else
        # Param in specific set
        params=$(rtconf ${1} ${ALL_SETS} -s ${SET_OPT_VAL} -l 2> /dev/null | \
            sed -n '/^-/{:1;p;n;/^-/q;b1};p' | grep '^ ' | awk '{print $1}')
        COMPREPLY=($(compgen -W "${params}" -- ${2}))
    fi
    return 0
}

_rtconf_param_val()
{
    # $1 = path
    # $2 = param
    # $3 = current word
    local val
    _get_set_opt_val
    _check_hidden
    if [[ "${SET_OPT_VAL}" == "" ]]; then
        # Param in active set
        val="\"$(rtconf ${1} ${ALL_SETS} get ${2} 2> /dev/null)\""
        COMPREPLY=$(compgen -W "${val}" -- ${3})
    else
        # Param in specific set
        val="\"$(rtconf ${1} ${ALL_SETS} -s ${SET_OPT_VAL} get ${2} 2> /dev/null)\""
        COMPREPLY=$(compgen -W "${val}" -- ${3})
    fi
    return 0
}

_rtconf_set()
{
    local cur set_name
    cur="${COMP_WORDS[COMP_CWORD]}"

    case ${COMP_WORDS[COMP_CWORD - 1]} in
        set) # No param yet - complete parameter names
            _rtconf_param_name "${COMP_WORDS[1]}" "${cur}"
            ;;
        *) # Have a param name - complete value
            _rtconf_param_val "${COMP_WORDS[1]}" \
                "${COMP_WORDS[COMP_CWORD - 1]}" "${cur}"
            ;;
    esac
    return 0
}

_rtconf()
{
    local cur prev confopts setopt
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD - 1]}"

    confopts="set get list act"

    if [[ ${prev} == *rtconf ]]
    then
        _rtobj ${cur}
        return 0
    fi

    if [[ ${cur} == -* ]]
    then
        _rtopts ${cur}
        return 0
    fi

    case "${prev}" in
        --set|-s)
            _rtconf_set_name "${COMP_WORDS[1]}" "${cur}"
            return 0
            ;;
        set)
            _rtconf_set
            return 0
            ;;
        get)
            _rtconf_param_name "${COMP_WORDS[1]}" "${cur}"
            return 0
            ;;
        list)
            return 0
            ;;
        act)
            return 0
            ;;
        =)
            if [[ "${COMP_WORDS[COMP_CWORD - 2]}" == "--set" ]]
            then
                _rtconf_set_name "${COMP_WORDS[1]}" "${cur}"
                return 0
            fi
            ;;
        *)
            if (( ${#COMP_WORDS[@]} >= 4 ))
            then
                if [[ "${COMP_WORDS[COMP_CWORD - 2]}" == "set" ]]
                then
                    _rtconf_set
                    return 0
                else
                    COMPREPLY=($(compgen -W "${confopts}" -- ${cur}))
                    return 0
                fi
            else
                COMPREPLY=($(compgen -W "${confopts}" -- ${cur}))
                return 0
            fi
            ;;
    esac

    return 0
}

_rtmgr()
{
    local cur prev mgropts setopt
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    mgropts="load unload create delete"

    if [[ ${cur} == -* ]] ; then
        _rtopts ${cur}
        return 0
    fi

    if [[ ${prev} == *.mgr ]] || [[ ${prev} == *.so ]]; then
        COMPREPLY=($(compgen -W "${mgropts}" -- ${cur}))
        return 0
    fi

    case "${prev}" in
        load)   # complete -A file
                return 0
                ;;
        unload) # complete -A file
                return 0
                ;;
        create) COMPREPLY=() # No completion
                return 0
                ;;
        delete) _rtobj ${cur} # Complete object name
                return 0
                ;;
        *)      ;;
    esac

    return 0
}

_rtshell(){
    local cur prev
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    if [[ ${cur} == -* ]] ; then
        _rtopts ${cur}
        return 0
    fi

    return 0
}

complete -F _rtls rtls
complete -F _rtls rtact
complete -F _rtls rtcat
complete -F _rtls rtcwd
complete -F _rtls rtdeact
complete -F _rtls rtexit
complete -F _rtls rtreset
complete -F _rtls rtfind
complete -F _rtls rtdel

complete -F _rtcon rtcon
complete -F _rtcon rtdis
complete -F _rtcon rtprint
complete -F _rtcon rtinject

complete -F _rtconf rtconf

complete -F _rtmgr -A file rtmgr

complete -F _rtshell -A file rtstart
complete -F _rtshell -A file rtstop
complete -F _rtshell -A file rtteardown
complete -F _rtshell -A file rtresurrect
complete -F _rtshell -A file rtcryo

